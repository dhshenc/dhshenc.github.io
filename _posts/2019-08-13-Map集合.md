---
layout: post
title: "Map集合"
date: 2019-08-13
tag: 集合
---
### 概念

**集合与数组的对比**

> 集合：就是一个存储数据的容器。<br>
> 集合与数组一样，也是一个容器，与数组的区别:<br>
> 1. 数组长度固定，集合的长度不固定。
> 2. 数组可以存储`基本类型`和`引用类型`，集合中存储的元素类型只能是`引用类型`(自动装箱和拆箱)。

### 集合的框架结构

> * Collection集合的框架结构
> ![Collection集合](/images/Collection集合.png)
> * Map集合的框架结构
> ![Map集合](/images/Map集合.png)

### 1. Collecation集合

> Collection 层次结构 中的根接口。Collection 表示一组对象，这些对象也称为 collection 的元素。一些 collection 允许有重复的元素，而另一些则不允许。一些 collection 是有序的，而另一些则是无序的。<br>
> List派系:可以重复、有序<br>
> Set派系:不能重复、无序
> * 代码就不贴出了。循环遍历可以用增强for和迭代器

### Map集合

> Map接口是将键映射到值的对象。一个映射不能包含重复的键，每个键最多只能映射到一个值，值可以重复。

> * 特点：<br>
> （1）存储的数据是键值对
> （2）键不能重复<br>
> （3）一个键对应一个值，值可以重复<br>
> （4）无序的

> * 循环遍历Map集合<br>
> （1）通过`KeySet()方法`得出key值，map.get(key)得出value值<br>
> （2）调用Map集合的`entrySet方法`，相当于将Map集合转成一个Set集合，再通过Set集合的遍历方式遍历即可。需要添加`泛型Set<Entry<String,String>>`，使用它调用`getkey()`和`getValue()`。

> * 演示代码:
> ```java
> //将map转成一个Set集合
> Set<Map.Entry<String, Integer>> set = map.entrySet();
> //遍历set
> Iterator<Map.Entry<String, Integer>> it=set.iterator();
> while(it.hasNext()) {
> 	System.out.println(it.next());
> }
> ```

### HashMap集合

> 基于哈希表的Map接口的实现。此实现提供所有可选的映射操作，并允许使用`null值`和`null键`。此类不保证映射的顺序。

> * 存储特点:<br>
> 相对无序存储，元素以`键值对形式`存在，键不可以重复，值可以重复，但会覆盖之前的数据，元素`整体排重`，可以快速的通过键查找到所对应的值，通过`哈希表`实现的集合,`线程不安全`

> * 排重<br>
> HashMap集合的排重，只需要重写键所属的类的`hashCode`和`equals`方法即可。

> * 存储方式:<br>
> 哈希表（数组+链表/红黑树）<br>
> 默认`初始容量16`和默认`加载因子0.75`的空HashMap,如果小于等于6时，自动转化为链表。<br>
> JDK1.8 以后的 HashMap 在`解决哈希冲突`时有了较大的变化，当链表长度大于阈值（默认为8）时,并且输入长度大于等于64时，将链表`转化为红黑树`，以减少搜索时间<br>
> JDK1.8之前HashMap由`数组+链表`组成的，数组是HashMap的主体，`链表`则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）

### LinkedHashMap集合

> LinkedHashMap集合是具有可预知迭代顺序的Set接口的哈希表和链接列表实现。<br>
> 此实现与HashSet的不同之外在于，后者维护着一个运行于所有条目的`双重链接`列表。<br>
> 用法与HashSet类似。

> * 存储特点：<br>
> 有序存储，元素排重，通过链表实现的集合。

> LinkedHashMap继承自HashMap，所以它的底层仍然是基于`拉链式散列结构`即由数组和链表或红黑树组成。<br>
> 另外，LinkedHashMap在上面结构的基础上，增加了一条`双向链表`，使得上面的结构可以保持键值对的插入顺序。<br>
> 同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。

### Hashtable集合

> 此类实现一个哈希表，该哈希表将键映射到相应的值。任何非null对象都可以用作键或值。<br>
> Hashtable有一个子类Properties，Properties集合使用的比较频繁。

> * 存储特点：<br>
> 相对无序存储，元素排重，通过`哈希表`实现的集合。<br>
> `数组+链表`组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的

> * 特性:<br>
> `线程安全的`，但是效率非常低下。<br>
> 不允许存储`null键和值`。

### HashMap与Hashtable的区别

> Hashtable线程安全的，而HashMap线程不安全的<br>
> Hashtable中不允许存在null的键和null值，但是HashMap中允许null的键和null值

### TreeMap集合

> * 特点：<br>
> 存储键值对、键不能重复、一个键对应一个值、值可以重复<br>
> 无序，数据会进行排序。<br>
> 自平衡二叉`红黑树`<br>
> 排重依据：`Comparable接口`的`compareTo()`方法的返回值。如果返回0就认为是重复的元素。


**定制排序(可以参考set集合的文章)**

> 要实现Comparable接口<br>
> 定制比较器 Comparator

### ConcurrentHashMap集合

> * 特性：<br>
> jdk1.7采用分段的数组+链表，jdk1.8采用数组+链表/红黑二叉树<br>
> 实现`线程安全`的访问，性能和吞吐量远远高于HashTable<br>
> HashTable里使用的是`synchronized`关键字，这其实是对对象加锁，锁住的都是对象整体，当Hashtable的大小增加到一定的时候，性能会急剧下降，因为迭代时需要被锁定很长的时间。<br>
> ConcurrentHashMap算是对上述问题的优化.

### Conllections工具类
> - 去查API吧

### 价值两个亿的图片(重点)

**HashMap底层理解**
![HashMap图片](/images/HashMap.png)

<br>

转载请注明：[Memory的博客](https://www.shendonghai.com) » [点击阅读原文](https://www.shendonghai.com/2019/08/Map%E9%9B%86%E5%90%88/) 